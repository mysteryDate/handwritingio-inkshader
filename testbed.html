<html>
<head>
    <!-- Copyright 2016 Gracious Eloise, Inc. All rights reserved. -->

    <script src="stats.min.js"></script>
    <script src="dat.gui.js"></script>

    <script src="three.r78.js"></script>
    <script src="TrackballControls.js"></script>

    <script src="ChiselTipGeometry.js"></script>
    <script src="ChiselTipMesh.js"></script>

    <script src="TestStrokes.js"></script>
    <style>
        body {
            background: #f0f0f0;
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>

    <script id="vertex-shader" type="x-shader/x-vertex">
        // Just a simple vertex shader, used by all materials
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>

    <script id="fragment-shader-simple" type="x-shader/x-fragment">
        // Read from a texture, that's it
        varying vec2 vUv;
        uniform sampler2D _mainTex;
        uniform vec3 _color;

        void main() {
            vec4 tex = texture2D( _mainTex, vUv );
            gl_FragColor = vec4(1.) - (vec4( (vec3(1.) - _color) * (tex.g + tex.b),1.));
        }
    </script>

    <script id="fragment-shader-create-gradient-tex" type="x-shader/x-fragment">
        // Uses the red channel of a texture as a height map to create a gradient map
        // Needs a float value texture
        varying vec2 vUv;
        uniform sampler2D _mainTex;
        uniform vec2 _iResolution;
        vec2 offset[4];

        void main() {
            offset[0] = vec2(1.0,0.0);
            offset[1] = vec2(-1.0,0.0);
            offset[2] = vec2(0.0,-1.0);
            offset[3] = vec2(0.0,1.0);

            float height = texture2D(_mainTex, vUv).r;

            for(int i = 0; i < 4; i++) {
                // Find the height difference between this pixel and the one next to it
                float sideHeight = texture2D(_mainTex, vUv + offset[i] / _iResolution.xy).r;
                // Write it to a channel of hte texture
                gl_FragColor[i] = ((height - sideHeight) + 1.) / 2.;
            }
        }
    </script>

    <script id="fragment-shader-water-spread" type="x-shader/x-fragment">
        // Here we read from a heightmap and water texture to create another texture
        // This output texture uses the r, g, b, a channels to denote where the water should move
        // (r, g, b, a) => (right, left, up, down) 
        varying vec2 vUv;
        uniform sampler2D _waterTex;
        uniform sampler2D _gradientTex;
        uniform sampler2D _paperTex;
        uniform float _damping;

        vec2 offset[4];
        float heightChanges[4];

        void main() {
            // Green channel is the height of the water
            float waterHeight = texture2D(_waterTex, vUv).g;
            
            float paperHeight = texture2D(_paperTex, vUv).r;
            vec4 grad = 2. * texture2D(_gradientTex, vUv) - 1.;

            // Find all directions in which the water is goign down
            vec4 differences = max(vec4(0.), grad + vec4(1.) * (waterHeight + paperHeight));
            // Normalize it
            differences /= dot(differences, vec4(1.));
            // Scale it by waterHeight and damping
            gl_FragColor = differences * waterHeight * _damping;
        }
    </script>

    <script id="fragment-shader-water-absorb" type="x-shader/x-fragment">
        varying vec2 vUv;
        uniform sampler2D _moveTex;
        uniform sampler2D _waterTex;
        uniform sampler2D _paperTex;
        uniform vec2 _iResolution;
        uniform float _absorbRate;

        // For mouse response
        uniform vec2 _hiPoint;
        uniform float _mouseDown;

        vec2 offset[4];

        void main() {

            // Sample the four nearest pixes in the opposite diretion of the gradient tex
            offset[0] = vec2(-1.0,0.0);
            offset[1] = vec2(1.0,0.0);
            offset[2] = vec2(0.0,1.0);
            offset[3] = vec2(0.0,-1.0);

            float newWater = 0.;
            for(int i = 0; i < 4; i++) {
                newWater += texture2D(_moveTex, vUv + offset[i] / _iResolution.xy)[i];
            }
            newWater -= dot(texture2D(_moveTex, vUv), vec4(1.));

            float dist = 0.;
            if(_mouseDown > 0.5) 
            {
                // dist = 1.;
                dist = smoothstep(_iResolution.x / 32.,0.,length(_hiPoint.xy - gl_FragCoord.xy)) / _iResolution.x * 32. * 50.;
            }
            newWater += dist;

            vec4 tex = texture2D(_waterTex, vUv);
            tex.g += newWater;

            float paperHeight = texture2D(_paperTex, vUv).r;
            tex.g *= (1. - _absorbRate);
            tex.b += tex.g * _absorbRate;

            gl_FragColor = tex;
        }
    </script>

    <script id="fragment-shader-pingpong" type="x-shader/x-fragment">
        uniform sampler2D _mainTex;
        uniform sampler2D _backBuffer;
        uniform vec2 _iResolution;
        uniform float _damping;
        uniform vec3 _color;
        varying vec2 vUv;

        uniform float _mix;
        uniform sampler2D _paperTex;

        uniform vec2 _hiPoint;
        uniform float _mouseDown;

        uniform vec4 _floats;

        vec2 offset[4];
        float heights[4];

        void main() {

            offset[0] = vec2(-1.0,0.0);
            offset[1] = vec2(1.0,0.0);
            offset[2] = vec2(0.0,1.0);
            offset[3] = vec2(0.0,-1.0);

            vec3 sum = vec3(0.,0.,0.);
            for(int i = 0; i < 4; i++) {
                sum += texture2D(_mainTex, vUv + offset[i] / _iResolution.xy).rgb;
            }
            sum = (sum / 2.0) - texture2D(_backBuffer, vUv).rgb;
            // sum *= 0.25;
            sum *= _damping;
            vec3 currentColor = texture2D(_mainTex, vUv).rgb;

            float dist = 0.;
            if(_mouseDown > 0.5) 
            {
                dist = smoothstep(_floats.z,0.,length(_hiPoint.xy - gl_FragCoord.xy)) / _floats.z * 20.;
            }
            float paperMix = pow(_mix * texture2D(_paperTex, vUv).r, _floats.x) * _floats.y;

            gl_FragColor =vec4((1.-paperMix)*currentColor + paperMix*sum - dist * (vec3(1.,1.,1.) - _color), 1.);
            // gl_FragColor =vec4((1.-paperMix)*currentColor + paperMix*sum + dist * _color, 1.);
        }
    </script>

    <script>
        // Global stuff
        var canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        var stats = new Stats();
        document.body.appendChild(stats.domElement);
        var gui = new dat.GUI();
        var dpr = window.devicePixelRatio;
        var renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});
        renderer.setPixelRatio(dpr);
        renderer.setSize(window.innerWidth, window.innerHeight);
        // renderer.setClearColor(0xffffff);
        var texRes = new THREE.Vector2(window.innerWidth, window.innerHeight);
        // --------

        // Cameras
        var camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000 );
        // Separate camera for render to texture
        var cameraRTT = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000 );
        // --------

        // Textures
        var textureOptions = {
            inFilter: THREE.LinearFilter,
            magFilter: THREE.NearestFilter,
            format: THREE.RGBAFormat,
            type: THREE.FloatType,
            depthBuffer: false,
            stencilBuffer: false
        }
        // Texture to render to
        var outputTex = new THREE.WebGLRenderTarget( texRes.x, texRes.y, textureOptions );
        // For ping-ponging
        var tex1 = new THREE.WebGLRenderTarget( texRes.x, texRes.y, textureOptions );
        // Because webGL complains when you sample from and write to the same texture
        var tex2 = new THREE.WebGLRenderTarget( texRes.x, texRes.y, textureOptions );
        var moveTex = new THREE.WebGLRenderTarget( texRes.x, texRes.y, textureOptions );
        var gradientTex = new THREE.WebGLRenderTarget( texRes.x, texRes.y, textureOptions );
        // gradientTex.texture.type = THREE.FloatType;
        // --------

        // Fullscreen quad for ping-ponging
        var pingpongScene = new THREE.Scene();
        var pingpongMaterial = new THREE.ShaderMaterial( {
            uniforms: { 
                _mainTex: { value: tex1.texture },
                _backBuffer: { value: tex2.texture },
                _paperTex: { value: tex1.texture },
                _iResolution: { value: new THREE.Vector2( texRes.x, texRes.y)},
                _damping: {value: 0.99},
                _hiPoint: {value: new THREE.Vector2(0.,0.)},
                _mouseDown: {value: 0.},
                _color: {value: new THREE.Color('#ffffff')},
                _mix: {value: 1.},
                _floats: {value: new THREE.Vector4(1.,1.,1.,1.)}
            },
            vertexShader: document.getElementById( 'vertex-shader' ).textContent,
            fragmentShader: document.getElementById( 'fragment-shader-pingpong' ).textContent,

            depthWrite: false

        } );
        var plane = new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight );
        var quad = new THREE.Mesh( plane, pingpongMaterial );
        quad.position.z = -100;
        pingpongScene.add( quad );
        // --------

        // Basic output scene
        var outputScene = new THREE.Scene();
        var basicMaterial = new THREE.ShaderMaterial( {
            uniforms: {
                _mainTex: {value: tex1.texture},
                _color: {value: new THREE.Color('#ffffff')}
            },
            vertexShader: document.getElementById('vertex-shader').textContent,
            fragmentShader: document.getElementById('fragment-shader-simple').textContent
        })
        var outputQuad = new THREE.Mesh( plane, basicMaterial );
        outputQuad.position.z = -100;
        outputScene.add( outputQuad );
        // --------

        // Just for the writing mesh
        var writingScene = new THREE.Scene();
        // --------

        // Controller
        var mesh, boundingBox;
        var controller = {
            degrees: 60,
            lineWidth: 3.5,
            color: "#00ff00",
            wireframe: false,
            damping: 1.,
            mix: 1.,
            absorbRate: 0.01,
            floatsx: 1.,
            floatsy: 1.,
            floatsz: 50.,
            floatsw: 1.,

            restart: function() {
                if (mesh) {
                    // TODO: dispose
                    writingScene.remove(mesh);
                }
                mesh = new ChiselTipMesh({
                    strokeData: TestStrokes[3].strokeData,
                    degrees: controller.degrees,
                    lineWidth: controller.lineWidth,
                    color: new THREE.Color(controller.color),
                });
                mesh.geometry.center();
                mesh.material.wireframe = controller.wireframe;
                writingScene.add(mesh);
                mesh.start();

                boundingBox = new THREE.Box3().setFromObject(mesh);
                var aspect = window.innerWidth / window.innerHeight;
                var newWidth = boundingBox.max.x - boundingBox.min.x;
                var newHeight = newWidth/aspect;
                cameraRTT = new THREE.OrthographicCamera( boundingBox.min.x, boundingBox.max.x, boundingBox.max.x / aspect, boundingBox.min.x / aspect, -10000, 10000 );
                plane = new THREE.PlaneBufferGeometry( newWidth, newHeight );
                pingpongScene.remove(quad);
                quad = new THREE.Mesh( plane, pingpongMaterial );
                quad.position.z = -100;
                pingpongScene.add( quad );
            },

            clear: function() {
                writingScene.remove(mesh);
                renderer.render( writingScene, cameraRTT, tex1 );
                renderer.render( writingScene, cameraRTT, tex2 );
                renderer.render( writingScene, cameraRTT, moveTex );
                mesh.start();
            }
        }
        controller.restart();

        gui.add(controller, "degrees", 0, 359).onChange(controller.restart);
        gui.add(controller, "lineWidth", 0.1, 10).onChange(controller.restart);
        gui.addColor(controller, "color").listen();
        gui.add(controller, "wireframe").onChange(controller.restart);
        gui.add(controller,"damping",0.,1.).listen();
        gui.add(controller,"mix",0.,1.).listen();
        gui.add(controller,"absorbRate",0.0,0.2).listen();
        gui.add(controller,"floatsx").listen();
        gui.add(controller,"floatsy").listen();
        gui.add(controller,"floatsz").listen();
        gui.add(controller,"floatsw").listen();
        gui.add(controller, "restart");
        gui.add(controller, "clear");
        // --------

        copyScene = new THREE.Scene();
        var copyMat = new THREE.ShaderMaterial({
            uniforms: {
                _mainTex: {value: tex1.texture},
                _iResolution: { value: new THREE.Vector2( texRes.x, texRes.y)}
            },
            vertexShader: document.getElementById( 'vertex-shader' ).textContent,
            fragmentShader: document.getElementById( 'fragment-shader-create-gradient-tex' ).textContent
        });
        quad = new THREE.Mesh( plane, copyMat );
        quad.position.z = -100;
        copyScene.add(quad);

        var spreadMat = new THREE.ShaderMaterial({
            uniforms: {
                _waterTex: {value: tex1.texture},
                _paperTex: {value: tex1.texture},
                _gradientTex: {value: gradientTex.texture},
                _iResolution: { value: new THREE.Vector2( texRes.x, texRes.y)},
                _damping: {value: 0.1}
            },
            vertexShader: document.getElementById( 'vertex-shader' ).textContent,
            fragmentShader: document.getElementById( 'fragment-shader-water-spread').textContent
        });
        var absorbMat = new THREE.ShaderMaterial({
            uniforms: {
                _moveTex: {value: moveTex.texture},
                _waterTex: {value: tex1.texture},
                _paperTex: {value: tex1.texture},
                _absorbRate: {value: 0.},
                _iResolution: { value: new THREE.Vector2( texRes.x, texRes.y)},
                _hiPoint: {value: new THREE.Vector2(0.,0.)},
                _mouseDown: {value: 0.}
            },
            vertexShader: document.getElementById( 'vertex-shader' ).textContent,
            fragmentShader: document.getElementById( 'fragment-shader-water-absorb' ).textContent
        });
        spreadScene = new THREE.Scene();
        spreadQuad = new THREE.Mesh( plane, spreadMat );
        spreadScene.add(spreadQuad);
        absorbScene = new THREE.Scene();
        absorbQuad = new THREE.Mesh( plane, absorbMat );
        absorbScene.add(absorbQuad);

        
        function render() {
            window.setTimeout(function() {
                requestAnimationFrame(render);
            }, 0);
            stats.update();

            spreadMat.uniforms._damping.value = controller.damping;
            basicMaterial.uniforms._color.value = new THREE.Color(controller.color);
            absorbMat.uniforms._absorbRate.value = controller.absorbRate;
            // pingpongMaterial.uniforms._damping.value = 1 + controller.damping/1000.;
            // pingpongMaterial.uniforms._mix.value = controller.mix;
            // pingpongMaterial.uniforms._floats.value = new THREE.Vector4(controller.floatsx, controller.floatsy, controller.floatsz, controller.floatsw);

            if ( mesh.isAnimating() ) 
            {
                renderer.render( writingScene, cameraRTT, tex1 );
            }
            // else 
            // {
            //     pingpongMaterial.uniforms._color.value = new THREE.Color(controller.color);
            //     renderer.render( pingpongScene, cameraRTT, outputTex );
            //     // Ping pong the textures
            //     var a = tex1;
            //     tex1 = outputTex;
            //     outputTex = tex2;
            //     tex2 = a;

            //     // Set the proper values, tex1 + tex2 (copy of outputTex) --> writes to outputTex
            //     pingpongMaterial.uniforms._mainTex.value = tex1.texture;
            //     pingpongMaterial.uniforms._backBuffer.value = tex2.texture;

            //     // Make sure the main camera is using the right texture
            //     basicMaterial.uniforms._mainTex.value = tex1.texture;
            // }

            renderer.render( spreadScene, cameraRTT, moveTex);
            renderer.render( absorbScene, cameraRTT, tex2 );

            var a = tex1;
            tex1 = tex2;
            tex2 = a;

            absorbMat.uniforms._waterTex.value = tex1.texture;
            spreadMat.uniforms._waterTex.value = tex1.texture;
            if(controller.floatsx < 1) 
                basicMaterial.uniforms._mainTex.value = tex1.texture;
            else if(controller.floatsx < 2) 
                basicMaterial.uniforms._mainTex.value = tex2.texture;
            else if(controller.floatsx < 3) 
                basicMaterial.uniforms._mainTex.value = moveTex.texture;
            else if(controller.floatsx > 3) 
                basicMaterial.uniforms._mainTex.value = gradientTex.texture;
            // basicMaterial.uniforms._mainTex.value = tex2.texture;

            // copyMat.uniforms._mainTex.value = tex2.texture;
            renderer.render( outputScene, camera );
        }

        canvas.onmousedown = function(e) {
            pingpongMaterial.uniforms._mouseDown.value = 1.0;
            absorbMat.uniforms._mouseDown.value = 1.0;
        }
        canvas.onmousemove = function(e) {
            pingpongMaterial.uniforms._hiPoint.value = new THREE.Vector2(
                e.clientX * texRes.x / window.innerWidth, (window.innerHeight - e.clientY) * texRes.y / window.innerHeight
            );
            absorbMat.uniforms._hiPoint.value = new THREE.Vector2(
                e.clientX * texRes.x / window.innerWidth, (window.innerHeight - e.clientY) * texRes.y / window.innerHeight
            );
        }
        canvas.onmouseup = function(e) {
            pingpongMaterial.uniforms._mouseDown.value = 0.0;
            absorbMat.uniforms._mouseDown.value = 0.0;
        }

        // For our paper
        var loader = new THREE.TextureLoader();
        loader.load('cracked-mud-inverted.png', function ( paperTex ) {
            
            copyMat.uniforms._mainTex.value = paperTex;
            spreadMat.uniforms._paperTex.value = paperTex;
            absorbMat.uniforms._paperTex.value = paperTex;
            pingpongMaterial.uniforms._paperTex.value = paperTex;
            controller.restart();

            renderer.render(copyScene, cameraRTT, gradientTex);

            render();
        });
    </script>
</body>
